import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:logger/logger.dart';
import 'package:nexa/core/network/api_client.dart';
import 'package:nexa/core/network/network_info.dart';
import 'package:nexa/core/utils/logger.dart';
import 'package:nexa/features/cities/data/services/city_service.dart';
import 'package:nexa/features/brand/data/providers/brand_provider.dart';
import 'package:nexa/features/subscription/data/services/subscription_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

// This will be generated by injectable_generator
// Run: flutter pub run build_runner build --delete-conflicting-outputs
// to generate injection.config.dart
// part 'injection.config.dart';

/// GetIt service locator instance
final getIt = GetIt.instance;

/// Configures all dependencies for the application
/// This is the main entry point for dependency injection
@InjectableInit(
  initializerName: 'init',
  preferRelativeImports: true,
  asExtension: true,
)
Future<void> configureDependencies() async {
  // Register external dependencies that need async initialization
  await _registerExternalDependencies();

  // Initialize injectable dependencies
  // Uncomment this when injection.config.dart is generated:
  // getIt.init();
}

/// Registers external dependencies that are not annotated with @injectable
Future<void> _registerExternalDependencies() async {
  // SharedPreferences - needs async initialization
  final sharedPreferences = await SharedPreferences.getInstance();
  getIt.registerLazySingleton<SharedPreferences>(() => sharedPreferences);

  // FlutterSecureStorage - different initialization for web vs mobile
  final secureStorage = kIsWeb
      ? const FlutterSecureStorage()
      : const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: true,
          ),
        );
  getIt.registerLazySingleton<FlutterSecureStorage>(() => secureStorage);

  // Connectivity
  getIt.registerLazySingleton<Connectivity>(() => Connectivity());

  // Dio
  getIt.registerLazySingleton<Dio>(() => Dio());

  // Logger
  getIt.registerLazySingleton<Logger>(() => AppLogger.instance);

  // Register core services
  _registerCoreServices();
}

/// Registers core services that depend on external dependencies
void _registerCoreServices() {
  // Network Info
  getIt.registerLazySingleton<NetworkInfo>(
    () => NetworkInfoImpl(getIt<Connectivity>()),
  );

  // API Client
  getIt.registerLazySingleton<ApiClient>(
    () => ApiClient(
      secureStorage: getIt<FlutterSecureStorage>(),
      logger: getIt<Logger>(),
      dio: getIt<Dio>(),
    ),
  );

  // City Service
  getIt.registerLazySingleton<CityService>(
    () => CityService(getIt<ApiClient>()),
  );

  // Subscription Service
  getIt.registerLazySingleton<SubscriptionService>(
    () => SubscriptionService(getIt<ApiClient>()),
  );

  // Brand Provider
  getIt.registerLazySingleton<BrandProvider>(
    () => BrandProvider(getIt<ApiClient>()),
  );
}

/// Resets all dependencies (useful for testing)
Future<void> resetDependencies() async {
  await getIt.reset();
}

/// Example of how to register services, repositories, and use cases
/// These would typically be in their respective feature modules
///
/// // Services
/// @lazySingleton
/// class AuthService {
///   AuthService(this._apiClient);
///   final ApiClient _apiClient;
/// }
///
/// // Repositories
/// @LazySingleton(as: AuthRepository)
/// class AuthRepositoryImpl implements AuthRepository {
///   AuthRepositoryImpl(this._authService);
///   final AuthService _authService;
/// }
///
/// // Use Cases
/// @lazySingleton
/// class LoginUseCase {
///   LoginUseCase(this._repository);
///   final AuthRepository _repository;
/// }
///
/// // BLoCs/Cubits
/// @injectable
/// class AuthBloc extends Bloc<AuthEvent, AuthState> {
///   AuthBloc(this._loginUseCase) : super(AuthInitial());
///   final LoginUseCase _loginUseCase;
/// }
